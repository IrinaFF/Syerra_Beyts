Обозреватель универсальных сервисов —
это что-то вроде специализированного браузера,
только вместо HTML-страниц он будет загружать и отображать интерактивные
пользовательские интерфейсы, которые мы называем универсальными сервисами.

Как это работает:
1. Сервисный браузер (клиент)
Клиент запускается  и ищет сервис ServiceServer в реестре RMI, получая в ответ «заглушку».
2. Сервисный браузер (клиент)
Клиент вызывает из «заглушки» метод getServiceList(). ServiceServer возвращает список сервисов.
3. Сервисный браузер (клиент)
Клиент отображает список сирвисов в GUI.
4. Пользователь выбирает один пункт из списка, после чего клиент
   вызывает метод getService() из удаленного сервиса. Метод возвращает
   сериализованный объект — это и есть сервис, который будет работать
   внутри клиентского обозревателя.
5. Клиент вызывает getGuiPanel() из сериализованного объекта,
   отправленного удаленным сервисом. GUI для этого сервиса отображается
   внутри обозревателя, и пользователь может взаимодействовать с ним
   локально. Таким образом, удаленный сервис не нужен нам до тех пор,
   пока пользователь его не выберет.

Классы и интерфейсы
1. Интерфейс ServiceServer унаследован от удаленного интерфейса
Старый добрый удаленный RMI-интерсрейс для удаленного
сервиса (последний содержит методы для получения списка
сервисов и выбора одного из них).

2. Класс ServiceServerXmpI реализует ServiceServer
Настоящий удаленный RMI-сервис (наследует
UnicastRemoteObject). Его задача —создать экземпляры всех
сервисов (сущностей, которые будут передаваться клиенту)
и хранить их. Он также должен внести себя в реестр RMI.

3. Класс ServiceBrowser
Это клиент. Ои создает очень простой GUI и выполняет поиск по
реестру RMI, чтобы получить «заглушку» ServiceServer. После
этого он вызывает из нее удаленный метод, возвращающий набор
сервисов, которые будут отображаться в раскрывающемся списке.

4. Интерфейс Service
Ключевой компонент всей системы. Этот очень простой
интерфейс содержит всего один метод —get<5uiPanel(). Его должны
реализовывать все сервисы, которые передаются клиенту. В этом
и состоит универсальность! После реализации этого интерфейса
сервис можно отправить клиенту, даже если тому не известен
его класс (или классы). Клиент знает только одно: что бы ему ни
пришло по сети, оно реализует интерфейс Service, а значит, должно
содержать метод getGuiPanel().
В результате вызова метода getService(selectSvc) из «заглушки»
ServiceStub клиент получает сериализованный объект. Он говорит
этому объекту примерно следующее: «Я не знаю, кто ты и что ты, но
мне известно, что ты реализуешь интерфейс Service, поэтому я знаю,
что могу вызвать из тебя метод getGuiPanel(). И поскольку этот метод
возвращает JPanel, я просто добавлю его внутрь пользовательского
интерфейса обозревателя и начну с ним работать!»

5. Класс DiceService реализует Service
Это сервис, представляющий виртуальные игральные кости.
Используйте его, чтобы получить случайное число от 1 до 6.

6. Класс MiniMusicService реализует Service
Помните потрясающую программу из Кухни кода, в которой
речь впервые зашла о GUI? Она еще выводила на экран «видео»
в такт музыке. Мы превратили ее в сервис, и теперь вы можете
включать ее снова и снова, пока ваши соседи по комнате
наконец не уйдут.

7. Класс DayOfTheWeekService реализует Service
В какой день недели вы родились? Введите день своего
рождения и узнайте сами.